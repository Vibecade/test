<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moonbase Holodeck</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.6;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>MOONBASE HOLODECK</strong><br>
        WASD - Move | Mouse - Look Around<br>
        Space - Jump | Click to lock pointer
    </div>
    <div id="crosshair"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 50, 200);
        
        // Camera (eye level for VR)
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.7, 5); // Human eye height
        
        // Renderer with WebXR support
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Custom WebXR VR button (THREE.VRButton not available in r128)
        function createVRButton() {
            const button = document.createElement('button');
            button.style.position = 'absolute';
            button.style.bottom = '20px';
            button.style.left = '50%';
            button.style.transform = 'translateX(-50%)';
            button.style.padding = '12px 24px';
            button.style.border = 'none';
            button.style.borderRadius = '8px';
            button.style.background = '#00a8ff';
            button.style.color = 'white';
            button.style.font = 'bold 14px Arial';
            button.style.cursor = 'pointer';
            button.style.zIndex = '999';
            button.textContent = 'ENTER VR';
            
            button.onclick = function() {
                if (navigator.xr) {
                    navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                        if (supported) {
                            renderer.xr.getSession() ? 
                                renderer.xr.getSession().end() : 
                                navigator.xr.requestSession('immersive-vr').then((session) => {
                                    renderer.xr.setSession(session);
                                });
                        } else {
                            button.textContent = 'VR NOT SUPPORTED';
                            button.style.background = '#666';
                        }
                    });
                } else {
                    button.textContent = 'WEBXR NOT AVAILABLE';
                    button.style.background = '#666';
                }
            };
            
            return button;
        }
        
        document.body.appendChild(createVRButton());
        
        // Lighting - Moon environment (harsh shadows, no atmosphere)
        const sunlight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunlight.position.set(50, 100, 50);
        sunlight.castShadow = true;
        sunlight.shadow.mapSize.width = 2048;
        sunlight.shadow.mapSize.height = 2048;
        sunlight.shadow.camera.far = 200;
        scene.add(sunlight);
        
        // Ambient light (reflected from Earth)
        const earthGlow = new THREE.AmbientLight(0x4d7a9f, 0.3);
        scene.add(earthGlow);
        
        // Starfield skybox
        const starGeometry = new THREE.BufferGeometry();
        const starVertices = [];
        for (let i = 0; i < 5000; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            starVertices.push(x, y, z);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
        
        // Moon surface (realistic regolith texture)
        const moonGround = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200, 50, 50),
            new THREE.MeshStandardMaterial({ 
                color: 0x8c8c8c,
                roughness: 0.95,
                metalness: 0.1
            })
        );
        moonGround.rotation.x = -Math.PI / 2;
        moonGround.receiveShadow = true;
        
        // Add surface detail with displacement
        const vertices = moonGround.geometry.attributes.position.array;
        for (let i = 0; i < vertices.length; i += 3) {
            vertices[i + 2] = Math.random() * 0.5 - 0.25; // Random height variation
        }
        moonGround.geometry.attributes.position.needsUpdate = true;
        moonGround.geometry.computeVertexNormals();
        scene.add(moonGround);
        
        // Add craters
        for (let i = 0; i < 15; i++) {
            const craterSize = Math.random() * 3 + 1;
            const crater = new THREE.Mesh(
                new THREE.CylinderGeometry(craterSize, craterSize * 0.8, 0.3, 16),
                new THREE.MeshStandardMaterial({ 
                    color: 0x6b6b6b,
                    roughness: 0.98
                })
            );
            crater.position.set(
                Math.random() * 100 - 50,
                -0.15,
                Math.random() * 100 - 50
            );
            crater.receiveShadow = true;
            crater.castShadow = true;
            scene.add(crater);
        }
        
        // Space igloo (4x4 meters dome)
        const iglooRadius = 2;
        const iglooSegments = 16;
        const igloo = new THREE.Mesh(
            new THREE.SphereGeometry(iglooRadius, iglooSegments, iglooSegments, 0, Math.PI * 2, 0, Math.PI / 2),
            new THREE.MeshStandardMaterial({ 
                color: 0xe8e8e8,
                roughness: 0.7,
                metalness: 0.3,
                side: THREE.DoubleSide
            })
        );
        igloo.position.set(10, 0, -10);
        igloo.castShadow = true;
        igloo.receiveShadow = true;
        scene.add(igloo);
        
        // Igloo entrance
        const entrance = new THREE.Mesh(
            new THREE.CylinderGeometry(0.8, 0.8, 1.5, 8),
            new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.9
            })
        );
        entrance.position.set(10, 0.75, -8);
        entrance.rotation.x = Math.PI / 2;
        entrance.castShadow = true;
        scene.add(entrance);
        
        // Earth in sky (visible from moon)
        const earthGeometry = new THREE.SphereGeometry(8, 32, 32);
        const earthMaterial = new THREE.MeshStandardMaterial({
            color: 0x2233ff,
            emissive: 0x112244,
            emissiveIntensity: 0.5
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earth.position.set(30, 40, -80);
        scene.add(earth);
        
        // Add cloud layer to Earth
        const cloudGeometry = new THREE.SphereGeometry(8.2, 32, 32);
        const cloudMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.4
        });
        const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
        clouds.position.copy(earth.position);
        scene.add(clouds);
        
        // Movement controls
        const keys = {};
        const moveSpeed = 0.15;
        const jumpForce = 0.3;
        let velocity = new THREE.Vector3();
        let canJump = true;
        
        // VR controllers setup
        const controller1 = renderer.xr.getController(0);
        const controller2 = renderer.xr.getController(1);
        scene.add(controller1);
        scene.add(controller2);
        
        // Controller interaction
        const tempMatrix = new THREE.Matrix4();
        const raycaster = new THREE.Raycaster();
        
        controller1.addEventListener('selectstart', onSelectStart);
        controller2.addEventListener('selectstart', onSelectStart);
        
        function onSelectStart(event) {
            const controller = event.target;
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            // VR teleport or interaction logic can be added here
        }
        
        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        
        // Mouse controls
        let isPointerLocked = false;
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        
        renderer.domElement.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });
        
        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isPointerLocked) return;
            
            euler.setFromQuaternion(camera.quaternion);
            euler.y -= e.movementX * 0.002;
            euler.x -= e.movementY * 0.002;
            euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
            camera.quaternion.setFromEuler(euler);
        });
        
        // Animation loop
        renderer.setAnimationLoop(animate);
        
        function animate() {
            // Movement (desktop controls)
            if (!renderer.xr.isPresenting) {
                const direction = new THREE.Vector3();
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                
                camera.getWorldDirection(forward);
                forward.y = 0;
                forward.normalize();
                
                right.crossVectors(forward, camera.up).normalize();
                
                if (keys['w']) direction.add(forward);
                if (keys['s']) direction.sub(forward);
                if (keys['d']) direction.add(right);
                if (keys['a']) direction.sub(right);
                
                direction.normalize().multiplyScalar(moveSpeed);
                camera.position.add(direction);
                
                // Reduced gravity jump
                if (keys[' '] && canJump) {
                    velocity.y = jumpForce;
                    canJump = false;
                }
                
                // Apply gravity (1/6 Earth's gravity)
                velocity.y -= 0.003;
                camera.position.y += velocity.y;
                
                // Ground collision
                if (camera.position.y <= 1.7) {
                    camera.position.y = 1.7;
                    velocity.y = 0;
                    canJump = true;
                }
            }
            
            // Earth rotation
            earth.rotation.y += 0.001;
            clouds.rotation.y += 0.0015;
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
